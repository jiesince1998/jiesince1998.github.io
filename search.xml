<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title></title>
      <link href="/2018/04/27/%E6%B8%B8%E6%88%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
      <url>/2018/04/27/%E6%B8%B8%E6%88%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>游戏的基本结构:</p><pre><code>    游戏是什么呢? 在游戏中, 往往是显示各种各样的画面, 玩家可以做一些设定好的控制, 画面根据玩家的控制有所变化.从这可以看出, 游戏至少需要三个功能---显示画面, 接受玩家输入和对输入产生反馈. 这就是常说的渲染, 输入输出和逻辑三个模块. 将这三个模块组合在一起有很多方法.比如事件驱动---画面保持不变直到接收到输入事件, 程序进行逻辑运算然后改变画面. 而游戏往往不是这样, 游戏是事件驱动的. 也就是说无论有没有输入, 游戏都在不停地循环---检查是否是输入, 运行游戏逻辑(gameplay), 渲染画面. 游戏很像电影, 随着时间流逝画面在改变.    既然是时间驱动, 游戏中就会有帧的概念. 所谓帧就是在某个时刻显示在屏幕上的画面.从整体上看, 游戏就是一系列的帧不断播放着, 像动画片一样, 不过玩家可以通过交互改变播放的内容. 而我们开发游戏的主要内容就是安排每一帧的内容. 在每一次游戏循环中, 我们需要搜集玩家的输入,运行游戏逻辑以更新游戏的数据,根据更新后的数据安排下一帧显示的内容.所以一个最简单的游戏结构就是:     a). 初始化游戏: CCore(void). 初始化第三方库(SDL库), 创建游戏窗口(window), 创建渲染器(rR), 初始化一些变量(mainEvent, oMap)等等;    b). 是否结束游戏: while(!quitGame &amp;&amp; mainEvent-&gt;type != SDL_QUIT). 如果quitGame为true或者mainEvent-&gt;type == SDL_QUIT, 则退出游戏循环, 游戏结束;    就下来进入游戏主循环(oCore.mainLoop()): 这是游戏的主体, 每帧中的逻辑运算和图形处理都在这里面进行;    c). 搜集玩家输入信息: SDL_PollEvent(mainEvent). 将键盘输入信息进行缓冲以便在后面的游戏逻辑(gameplay)中判断按键状态;    d). 检测玩家输入信息: Input().     e). 运行游戏逻辑(gameplay): Update();    f). 更新和显示当前帧的游戏画面: Draw(), SDL_RenderPresent(rR);    g). 回到b), 继续下一帧的循环;</code></pre><p>键盘缓冲<br>        检测玩家输入信息是一个很重要的内容, 我们知道可以在d)阶段中就处理按键内容, 但这样做势必会将游戏逻辑代码分散在d)阶段和<br>    e)阶段. 你可能会想将所有游戏逻辑运算全部都放在c)阶段, 那可不行. 因为c)阶段只处理一些keyDown或keyUp之类的和键盘输入信息直接相关的事情,<br>    而即使没有按键,游戏也有很多逻辑运算要做(例如毒蘑菇不会因为玩家没有按键输入而停止自己的运动). 所以在游戏中我们选择采用键盘缓冲<br>    将按键信息保存起来, 然后mainLoop()就可以判断这一帧按键的状态, 进而在e)阶段根据当前帧的按键状态进行相应的逻辑运算. 利用按键缓冲, 除了可以判断<br>    一个键是否按下或松开, 还可以判断一个键是否一直被按住了, 甚至可以判断组合键.<br>状态机<br>        状态机是编译原理的内容, 看上去挺复杂的, 不过说白了就是选择分支结构. 但为什么要在这里提状态机呢? 其实它是一个简化问题的好工具,<br>    再复杂的问题都可以被分解成若干个小问题去解决. 虽然一个游戏很复杂, 但我们把它分解成若干块, 分而治之, 就简单多了. 分类的依据<br>    就是状态. 我们可以将一个游戏分解成很多状态. 比如主菜单状态, 游戏加载状态, 游戏运行状态, 暂停状态, “选项”菜单, “关于”菜单等.<br>    在状态中可以再细分子状态, 一直分下去, 直到问题变简单.<br>        游戏代码根据当前所处的状态进入相应的逻辑处理函数. 从某个角度来说, 游戏就是状态的集合, 我们要处理好状态之间的转换, 写好每个状态的代码.<br>渲染(render)<br>        在本游戏中, 渲染也就是绘制游戏画面, 没有渲染, 我们也就看不到五颜六色的游戏画面了. 整个游戏的渲染可以按层次进行. 首先是场景的渲染,然后是场景中的所有物体.<br>场景与角色<br>        场景与角色是构成游戏的两大要素. 从程序角度来说, 它们是两个重要的数据结构.<br>        场景是什么呢? 场景就是游戏角色所存在的世界(game world), 从视觉上看就是游戏的地图. 不过从程序角度看, 场景是一种数据结构, 不但包含了<br>    地图现实的图形信息也包含了角色在场景中活动所需要的物理信息和事件信息. 比如地图上有些地方是不可以通过的, 有些地方主角走过去会触发一个事件等等,<br>    这些信息往往包含在场景中. 广义的场景还包含游戏中的NPC(Non-Player-Character, 非玩家角色)信息, 狭义的场景只包含地图和物理层.<br>        那怎么组织图片来显示场景呢? 常用的办法是拼Tile, 俗称拼瓷砖. 整个场景用有限的图块拼接而成. 使用Tile方式, 一般使用一个二维数组标识一个地图.<br>    二维数组很好地对应了二维坐标.二维数组的每一项对应地图上某格使用哪个瓷砖, 整个二维数组就表示整张地图.<br>        最后说说场景中的物理作用和事件检测. 在场景中有些地方是无法通过的,有些地方主角走过去会触发某个机关(例如弹簧板, 藤蔓等). 这些信息往往也存储在<br>    场景信息中, 用另一个数组表示, 一般称为物理层,地形层或事件层等等. 最常用的信息就是碰撞信息, 它用来处理角色与地图,NPC的碰撞, 以及NPC之间的碰撞.</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>new-life</title>
      <link href="/2018/04/25/new-life-1/"/>
      <url>/2018/04/25/new-life-1/</url>
      <content type="html"><![CDATA[<p>新的站点, 新的世界!</p>]]></content>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
  
</search>
